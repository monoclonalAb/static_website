---
title: "Largest-Perimeter-Triangle"
question_id: "976"
question_link: "https://leetcode.com/problems/largest-perimeter-triangle/"
difficulty: "Easy"
---

You can sort `nums` from smallest to largest...

```cpp
sort(nums.begin(), nums.end());
```

... and then iterate backwards, with index `i`, checking if the last 3 elements (`i`, `i-1` & `i-2`) fit the **triangle inequality**.
If those 3 elements do not satisfy the **triangle inequality**, then no combination of elements with `i` as the *largest side* will form a *valid* triangle.

```cpp
for (int i = nums.size()-1; i >= 2; --i) {
    if (nums[i] < nums[i-1] + nums[i-2]) {
        return nums[i] + nums[i-1] + nums[i-2];
    }
}
return 0;
```

# cod<span>e</span>

```{.cpp}
class solution {
public:
    int largestperimeter(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for (int i = nums.size()-1; i >= 2; --i) {
            if (nums[i] < nums[i-1] + nums[i-2]) {
                return nums[i] + nums[i-1] + nums[i-2];
            }
        }
        return 0;
    }
};
```

## complexit<span>y</span>

:::sidebar
- Time: `O(n log(n))` where `n` denotes the number of elements inside of `nums`
- Space: `O(1)`
:::

## time take<span>n</span>

:::sidebar
- 3 minutes and 25 seconds
:::
