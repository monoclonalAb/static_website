---
title: "Find-the-Number-of-Ways-to-Place-People-II"
question_id: "3027"
question_link: "https://leetcode.com/problems/find-the-number-of-ways-to-place-people-ii/"
difficulty: "Hard"
---

Fortunately, running today's problem just seems to be a copy of [yesterday's problem](./2025-09-02.html)
except with larger constraints (maximum number of 1000 points instead of 50).

The only addition that I added was an early break in the double `for` loop:

```cpp
for (int i = 0; i < points.size()-1; ++i) {
    int y = INT32_MAX;
    for (int j = i+1; j < points.size(); ++j) {
        if (points[j][1] >= points[i][1] && y > points[j][1]) {
            ++ans;
            y = points[j][1];
            if (points[i][1] == points[j][1]) break; // this early break
        }
    }
}
```

This is because it is impossible to form a valid rectangle with `points[i]` in the **bottom-right** corner,
as `points[j]` will always lie inside, meaning we can afford to **early break**.

# cod<span>e</span>

```{.cpp}
class Solution {
public:
    int numberOfPairs(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), [](const auto& p1, const auto& p2) {
            return p1[0] == p2[0] ? p1[1] < p2[1] : p1[0] > p2[0];
        });

        int ans = 0;
        for (int i = 0; i < points.size()-1; ++i) {
            int y = INT32_MAX;
            for (int j = i+1; j < points.size(); ++j) {
                if (points[j][1] >= points[i][1] && y > points[j][1]) {
                    ++ans;
                    y = points[j][1];
                    if (points[i][1] == points[j][1]) break;
                }
            }
        }
        return ans;
    }
};
```

## complexit<span>y</span>

:::sidebar
- Time: `O(n^2)` where `n` denotes the number of elements inside `points`
- Space: `O(n)`
:::

## time take<span>n</span>

:::sidebar
- 2 minutes and 48 seconds
:::
