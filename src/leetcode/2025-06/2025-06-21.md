---
title: "Minimum-Deletions-to-Make-String-K-Special"
question_id: "3085"
question_link: "https://leetcode.com/problems/minimum-deletions-to-make-string-k-special/"
difficulty: "Medium"
---

Realise that once we iterate through `word` and gather the frequencies for each letter,
since we want to minimise deletions, we should iterate through all the letters in `alphabet`, `alphabet[i]`,
and set it as the `target`. Then, when we re-iterate through `alphabet` using index `j`, when `i != j`, we have:

:::sidebar
- `alphabet[j] < target`, meaning we have to make `alphabet[j]` number of deletions
- `alphabet[j] > target + k`, meaning we have to make `alphabet[j] - (target + k)` number of deletions 
:::

Then, we simply find the optimal `alphabet[i]` to set as the `target` and simply return the number of deletions made **in total**.

## Code<span>:</span>

```{.cpp}
class Solution {
public:
    int minimumDeletions(string word, int k) {
        int alphabet[26] = {0};
        for (char c : word) {
            ++alphabet[c-'a'];
        }
        int ans = INT32_MAX;
        for (int i = 0; i < 26; ++i) {
            if (alphabet[i] == 0) continue;
            int currAns = 0;
            for (int j = 0; j < 26; ++j) {
                if (i == j) continue;
                
                if (alphabet[j] > alphabet[i]+k) {
                    currAns += alphabet[j]-alphabet[i]-k;
                }
                if (alphabet[j] < alphabet[i]) {
                    currAns += alphabet[j];
                }
            }
            ans = min(ans, currAns);
        }
        return ans;
    }
};
```

### Complexity<span>:</span>

:::sidebar
- Time: `O(n)` where `n` is the size of `word`
- Space: `'O(1)`
:::

### Time Taken<span>:</span>

:::sidebar
- 19 minutes and 28 seconds
    - but I like fell asleep on the bus so this does not count-
:::
